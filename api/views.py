# -*- coding: utf-8 -*-

import datetime
from flask import request, abort, redirect, url_for, jsonify
from api import app, db, login_manager
import json
from bcrypt import hashpw, gensalt
from flask import session
from flask.ext.login import (LoginManager, current_user, login_required,
                            login_user, logout_user, UserMixin, AnonymousUser,
                            confirm_login, fresh_login_required)
from api.models import User, Moment, Invitation, Prospect, Photo, Device, Chat, Notification, Feed
from itsdangerous import URLSafeSerializer
import controller
import constants
import fonctions
import user.userConstants as userConstants
from sqlalchemy import desc, asc, and_, or_
import os
from instagram.client import InstagramAPI
import random
from PIL import Image




###################################
###### Flask Login functions ######
####################################

#Login_serializer used to encryt and decrypt the cookie token for the remember
#me option of flask-login
login_serializer = URLSafeSerializer(app.secret_key)

@login_manager.user_loader
def load_user(userid):
    """
    Flask-Login user_loader callback.
    The user_loader function asks this function to get a User Object or return 
    None based on the userid.
    The userid was stored in the session environment by Flask-Login.  
    user_loader stores the returned User object in current_user during every 
    flask request. 
    """
    user = User.query.get(userid)

    #On update la derniere connection du user
    if user is not None:
    	user.update_last_connection()
    return user


@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback. 
    The token_loader function asks this function to take the token that was 
    stored on the users computer process it to check if its valid and then 
    return a User Object if its valid or None if its not valid.
    """

    #The Token itself was generated by User.get_auth_token.  So it is up to 
    #us to known the format of the token data itself.  

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which 
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre. 
    #max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()

    #Decrypt the Security Token, data = [username, hashpass]
    data = login_serializer.loads(token)

    #Find the User
    user = User.query.filter_by(email = data[0])

    #Check Password and return user or None
    if user and data[1] == user.pwd:
    	#On update la derniere connection du user
    	user.update_last_connection()
        return user
    return None







    #######################################################
    ################# REQUETES ############################
    #######################################################






@app.route('/')
@login_required
def index():
	user = User.query.filter(User.email == current_user.email).first()
	if user is None:
		return current_user.email
	else:
		return user.email



@app.route('/test')
def test():
	return '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">\
			<html>\
			<head>\
			<title>Webserver test</title>\
			</head>\
			<body>\
			This is a webserver test page.\
			</body>\
			</html>'


#################################################################
######## Requete pour ecouter un tag instagram ##################
##################################################################

@app.route("/addtag/<tag>")
def addtag(tag):
    payload = {'client_id': constants.INTAGRAM_CLIENT_ID, 'client_secret': constants.INSTAGRAM_CLIENT_SECRET, 'object':'tag', 'aspect':'media', 'object_id':tag, 'callback_url':'http://api.appmoment.fr/instagram'}
    r = requests.post("https://api.instagram.com/v1/subscriptions/", data=payload)

    return r.text



#################################################################
######## Requete pour enregistrer un nouvel utilisateur #########
##################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	password, email, firstname, lastname
# Autres paramètres possibles :
#	phone, facebookId, secondEmail, secondPhone

@app.route('/register', methods=["POST"])
def register():

	#On créé la réponse qui sera envoyé
	reponse = {}


	#On verifie que tous les champs obligatoires sont renseignés (email, password, firstname, lastname)
	if request.method == "POST" and "password" in request.form and "email" in request.form and "firstname" in request.form and "lastname" in request.form :

		#On recupere toutes les variable
		password = request.form["password"]
		hashpwd = hashpw(password, gensalt())
		email = request.form["email"]
		firstname = request.form["firstname"]
		lastname = request.form["lastname"]

		# Si un utilisateur avec cette adresse mail existe on ne peut pas créer un compte
		if controller.user_exist_email(email):
			reponse["error"] = "already exist"
			return jsonify(reponse), 405

		#On verifie aussi qu'un user avec ce facebookId n'existe pas
		#elif "facebookId" in request.form and controller.user_exist_fb(request.form["facebookId"]):
			#reponse["error"] = "already exist with this facebook account"
			#return jsonify(reponse), 405


		#Sinon nouvel utilisateur
		else:
			#On se créé un dictionnaire avec toutes les données
			potential_prospect = {}
			potential_prospect["email"] = email

			#On prend le phone si jamais il est valable
			if "phone" in request.form and fonctions.phone_controll(request.form["phone"]) is not None:
				phone = fonctions.phone_controll(request.form["phone"])
				potential_prospect["phone"] = phone["number"]

			if "facebookId" in request.form:
				potential_prospect["facebookId"] = request.form["facebookId"]



			#Quoi qu'il arrive on créé le user
			#On cree l'utilisateur
			user = User(email, firstname, lastname, hashpwd)


			###
			## Données non obligatoires : date d'anniversaire, et sexe
			###

			#On recupere les données non obligatoires
			if "birth_date" in request.form:
				user.birth_date = datetime.date.fromtimestamp(int(request.form["birth_date"]))
			if "sex" in request.form:
				if request.form["sex"] == constants.MALE:
					user.sex = constants.MALE
				elif request.form["sex"] == constants.FEMALE:
					user.sex = constants.FEMALE 
			if "lang" in request.form:
				user.lang = request.form["lang"]

			#On l'enregistre en base pour avoir un id
			db.session.add(user)
			db.session.commit()

			#Avant d'aller plus loin on le notifie par mail de son inscription
			user.notify_insciption()

			#On recupere le prospect si il existe
			prospect = controller.get_prospect(potential_prospect)


			###
			##	Test pour voir si Prospect existe
			##
			###


			#On a pas trouvé de prospect, on recupere les autres infos
			if prospect is None:
				#On essaye de remplir les autres champs
				#Pour les champs non obligatoires, si ils y sont on les recupere
				if "phone" in request.form and fonctions.phone_controll(request.form["phone"]) is not None:
					phone = fonctions.phone_controll(request.form["phone"])
					user.phone = phone["number"]
					user.phoneCountry = phone["country"]
				if "facebookId" in request.form:
					facebookId = request.form["facebookId"]
					user.facebookId = facebookId


			#Il existe un prospect donc il faut tout matcher
			else:
				#Matcher les moments
				prospect.match_moments(user)

				#Si on a pas certains champs dans l'inscirption on peut les recuperer du prospect
				if "phone" in request.form and fonctions.phone_controll(request.form["phone"]) is not None:
					phone = fonctions.phone_controll(request.form["phone"])
					user.phone = phone["number"]
					user.phoneCountry = phone["country"]

				elif prospect.phone is not None:
					user.phone = prospect.phone

				if "facebookId" in request.form:
					facebookId = request.form["facebookId"]
					user.facebookId = facebookId
				elif prospect.facebookId is not None:
					user.facebookId = prospect.facebookId

				if prospect.secondEmail is not None:
					user.secondEmail = prospect.secondEmail

				if prospect.secondPhone is not None:
					user.secondPhone = prospect.secondPhone

				if prospect.profile_picture_url is not None:
					user.profile_picture_url = prospect.profile_picture_url


				#On supprime le prospect
				db.session.delete(prospect)


			###
			##	Association du device
			##
			###

			#On rajoute ce device si il n'est pas déjà associé
			if "device_id" in request.form:
				device = user.add_device(request.form["device_id"], request.form["os"], request.form["os_version"], request.form["model"])

				#Si on a déjà l'id de notif 
				if "notif_id" in request.form:
					device.notif_id = request.form["notif_id"]
				else:
					user.desactivate_all_push_notifs()


			#Sinon on met à False toutes les notifs push
			else:
				user.desactivate_all_push_notifs()



			

			#On l ajoute en base
			db.session.commit()
			
			#Maintenant qu'on a l'id on enregistre la photo de profil
			
			if "photo" in request.files:
				f = request.files["photo"]
				#On enregistre la photo et son chemin en base
				name_picture = "%s" % user.id
				path_photo = user.add_profile_picture_aws(f, name_picture)
				#user.profile_picture_url = "http://%s%s" % (app.config.get("SERVER_NAME"), path_photo)
				#user.profile_picture_path = "%s%s" % (app.root_path, path_photo)
				#On enregistre en base
				db.session.commit()


			#On créé un faux Moment
			user.create_fake_moment()

			#On logge le user. On lui renvoit ainsi le token qu'il doit utiliser
			if login_user(user):
				session.permanent = True


			reponse["id"] = user.id

			return jsonify(reponse), 200

	else:
		reponse["error"] = "mandatory value missing"
		return jsonify(reponse), 405





######################################################
########  Requete pour Logger un  user ###############
#######################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	password, email
# Autres paramètres possibles :
#	

@app.route('/login', methods=["POST"])
def login():
	#On créé la réponse qui sera envoyé
	reponse = {}

	#On verifie que tous les champs sont renseignes
	if request.method == "POST" and "email" in request.form and "password" in request.form:
		email = request.form["email"]
		password = request.form["password"]

		#On recupere l utilisateur ayant de username
		user = User.query.filter_by(email = email).first()

		# Si l'utilisateur n'existe pas
		if user is None:
			reponse["error"] = "user does not exist"
			return jsonify(reponse), 401
		else:
			# On verifie que le password hashé correspond bien à celui en base
			if hashpw(password, user.pwd) == user.pwd:
				#On verifie si on nous fournie une langue afin de la modifier
				if "lang" in request.form:
					user.lang = request.form["lang"]
					db.session.commit()

				#On rajoute ce device si il n'est pas déjà associé
				if "device_id" in request.form:
					device = user.add_device(request.form["device_id"], request.form["os"], request.form["os_version"], request.form["model"])

					#Si on a déjà l'id de notif 
					if "notif_id" in request.form:
						device.notif_id = request.form["notif_id"]
						db.session.commit()


				if login_user(user):
					session.permanent = True
					reponse["success"] = "Logged"

				# On recupere les n prochains moments de ce user
				moments = controller.get_moments_of_user(user.email, 10)

				'''
				# On construit le tableau de moments que l'on va renvoyer
				reponse["moments"] = []
				for moment in moments:
					# Pour chacun des Moments on injecte que les données que l'on renvoit, et sous la bonne forme
					reponse["moments"].append(moment.moment_to_send())
				'''
				reponse["id"] = user.id

				return jsonify(reponse), 200
			else:
				reponse["error"] = "wrong password"


				return jsonify(reponse), 401

	else:
		reponse["error"] = "mandatory value missing"
		return jsonify(reponse), 405





######################################################
########  Requete pour céer un moment ###############
#######################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	name, address, startDate (YYYY-MM-DD), endDate (YYYY-MM-DD)
# Autres paramètres possibles :
#	placeInformations, startTime, endTime, description, hashtag, facebookId

@app.route('/newmoment', methods=["POST"])
@login_required
def new_moment():
    #On créé la réponse qui sera envoyé
    reponse = {}

    #On verifie que tous les champs sont renseignes
    if request.method == "POST" and "name" in request.form and "address" in request.form and "startDate" in request.form and "endDate" in request.form:
        ##
        # Recupération des valeurs obligatoires transmises
        ##
        name = request.form["name"]
        address = request.form["address"]

        #On recupere et met en forme la date (doit être au format "YYYY-MM-DD")
        startDate = fonctions.cast_date(request.form["startDate"])

        endDate = fonctions.cast_date(request.form["endDate"])



        #On créé un nouveau moment
        moment = Moment(name, address, startDate, endDate)
        #On enregistre en base
        #db.session.add(moment)
        #db.session.commit()

        ##
        # Recuperation des autres valeurs (non obligatoires)
        ##
        if "placeInformations" in request.form:
            placeInformations = request.form["placeInformations"]
            moment.placeInformations = placeInformations
        if "startTime" in request.form:
            moment.startTime = fonctions.cast_time(request.form["startTime"])
        if "endTime" in request.form:
            moment.endTime = fonctions.cast_time(request.form["endTime"])
        if "description" in request.form:
            description = request.form["description"]
            moment.description = description
        if "hashtag" in request.form:
            hashtag = request.form["hashtag"]
            moment.hashtag = hashtag

        #Si on fournit le Facebook Id alors c'est un event importé de Facebook
        if "facebookId" in request.form:
            print request.form["facebookId"]
            #Il faut vérifier qu'un Moment avec ce facebookId n'existe pas
            momentFb = Moment.query.filter(Moment.facebookId == request.form["facebookId"]).first()

            #Si ce moment existe déjà
            if momentFb is not None:
                #On rajoute ce user comme guest
                momentFb.add_guest(current_user.id, request.form["state"])
                db.session.commit()

                reponse = momentFb.moment_to_send(current_user.id)
                return jsonify(reponse), 200

            #Sinon on créé normalement le moment mais on attribut le state à ce user
            else:
                #On créé le Moment
                #On enregistre en base

                db.session.add(moment)
                db.session.commit()


                facebookId = request.form["facebookId"]
                moment.facebookId = facebookId


                #On rajoute le user en invité
                moment.add_guest(current_user.id, request.form["state"])
                print "ok"
                ###############
                ## On nous fournit un owner
                ###############

                owner = {}
                if  "owner_facebookId" in request.form:
                    owner["facebookId"] = request.form["owner_facebookId"]

                    #On voit si un user avec ce facebookId existe
                    userPot = User.query.filter(User.facebookId == owner["facebookId"]).first()
                    prospectPot = Prospect.query.filter(Prospect.facebookId == owner["facebookId"]).first()

                    if userPot is not None:
                        moment.add_guest(userPot.id, userConstants.OWNER)

                    #C est un prospect de notre base
                    elif prospectPot is not None:
                        moment.add_prospect(prospectPot)
                        #Si c'est un prospect on doit retenir quel facebook Id il a afin de le retrouver comme owner
                        moment.owner_facebookId = request.form["owner_facebookId"]

                    #Il n'existe pas en base, on créé un prospect en base et on le garde comme owner
                    else:
                        #On recupere les infos et on créé le prospect
                        if "owner_firstname" in request.form:
                            owner["firstname"] = request.form["owner_firstname"]
                        if "owner_lastname" in request.form:
                            owner["lastname"] = request.form["owner_lastname"]
                        if "owner_picture_url":
                            owner["photo_url"] = request.form["owner_picture_url"]

                        prospect = Prospect()
                        prospect.init_from_dict(owner)
                        moment.owner_facebookId = request.form["owner_facebookId"]
                        db.session.add(prospect)




                #On enregistre en base
                #db.session.add(moment)
                db.session.commit()

                #On créé tous les chemins necessaires au Moment (pour la sauvegarde des photos et de la cover)
                moment.create_paths()

                '''
                if "photo" in request.files:
                    f = request.files["photo"]
                    image = Image.open(f)

                    #On enregistre la photo et son chemin en base
                    name_picture = "cover_%s" % datetime.datetime.now().strftime("%s")
                    moment.add_cover_photo_aws(image, name_picture)
                    #On enregistre en base
                    db.session.commit()

                #Si on pas de photos
                else:
                    moment.cover_picture_url = constants.S3_DEFAULT_COVERS + "default%s.jpg" % (random.randint(1,4))
                    db.session.commit()
                '''

                if "photo_url" in request.form:
                    moment.cover_picture_url = request.form["photo_url"]
                    db.session.commit()



                if "privacy" in request.form:
                    if int(request.form["privacy"]) == constants.PRIVATE:
                        moment.privacy = constants.PRIVATE
                    elif int(request.form["privacy"]) == constants.OPEN:
                        moment.privacy = constants.OPEN

                        #On rajoute à l'actualité du User qu'il a créé un Moment
                        current_user.add_actu_new_moment(moment)

                    elif int(request.form["privacy"]) == constants.PUBLIC:
                        moment.privacy = constants.PUBLIC

                        #On rajoute à l'actualité du User qu'il a créé un Moment
                        current_user.add_actu_new_moment(moment)

                    db.session.commit()




                reponse = moment.moment_to_send(current_user.id)
                return jsonify(reponse), 200


        #On créé le Moment
        db.session.add(moment)
        db.session.commit()

        # On recupere en base le user qui créé ce Moment
        user = current_user

        #On créé l'invitation qui le lie à ce Moment
        # Il est owner, donc state à 0
        invitation = Invitation(userConstants.OWNER, user)

        #On ratache cette invitations aux guests du nouveau Moment
        moment.guests.append(invitation)


        db.session.commit()

        #On créé tous les chemins necessaires au Moment (pour la sauvegarde des photos et de la cover)
        moment.create_paths()

        if "photo" in request.files:
                f = request.files["photo"]
                image = Image.open(f)

                #On enregistre la photo et son chemin en base
                name_picture = "cover_%s" % datetime.datetime.now().strftime("%s")
                moment.add_cover_photo_aws(image, name_picture)
                #On enregistre en base
                db.session.commit()


                #On prend cette image et on la met comme premiere photo pas defaut dans le moment
                photo = Photo()

                #On enregistre en base l'objet photo
                db.session.add(photo)
                db.session.commit()

                #Puis on enregistre en disque la photo
                photo.save_photo(image, moment, current_user)


        #Si on pas de photos
        else:
            moment.cover_picture_url = constants.S3_DEFAULT_COVERS + "default%s.jpg" % (random.randint(1,4))
            db.session.commit()


        #De base on ajoute une photo au Moment (la photo est la cover)



        #Si le moment a un hashtag, on souscrit à INSTAGRAM
        '''
        if moment.hashtag is not None:
            verify_token = "%s" % moment.id
            instagram_client = InstagramAPI(client_id=constants.INSTAGRAM_CLIENT_ID, client_secret=constants.INSTAGRAM_CLIENT_SECRET)
            reponse = instagram_client.create_subscription(object='tag', object_id=moment.hashtag, aspect='media', verify_token = verify_token ,callback_url=constants.INSTAGRAM_CALLBACK_URL)
            print reponse
        '''

        reponse = moment.moment_to_send(user.id)
        return jsonify(reponse), 200

    else:
        reponse["error"] = "mandatory value missing"
        return jsonify(reponse), 405








#####################################################################
########  Requete pour récupérer les moments d'un user ###############
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/moments', methods=["GET"])
@login_required
def moments():
	#On créé la réponse qui sera envoyé
	reponse = {}

	user = User.query.get(current_user.id)
	moments_of_user_futur = user.get_moments_sup_date(10, datetime.date.today(), True)
	moments_of_user_past = user.get_moments_inf_date(10, datetime.date.today(), False)

	# On construit le tableau de moments que l'on va renvoyer
	reponse["moments"] = []
	for moment in reversed(moments_of_user_past):
		# Pour chacun des Moments on injecte que les données que l'on renvoit, et sous la bonne forme
		reponse["moments"].append(moment.moment_to_send(current_user.id))

	for moment in moments_of_user_futur:
		# Pour chacun des Moments on injecte que les données que l'on renvoit, et sous la bonne forme
		reponse["moments"].append(moment.moment_to_send(current_user.id))	

	reponse["success"] = "OK"

	return jsonify(reponse), 200




#####################################################################
########  Requete pour récupérer les moments d'un user donné ###############
######################################################################
###### A FAIRE !!!!!!! : Enlevé tous les moments privés et ne garder que ceux auxquel le user qui demande participe

# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/momentsofuser/<int:id_user>', methods=["GET"])
@login_required
def moments_of_user(id_user):
    #On créé la réponse qui sera envoyé
    reponse = {}

    user = User.query.get(id_user)

    if user is not None:

        moments_of_user_futur = user.get_moments_sup_date(constants.MAX_MOMENTS, datetime.date.today(), True)
        moments_of_user_past = user.get_moments_inf_date(constants.MAX_MOMENTS, datetime.date.today(), False)

        # On construit le tableau de moments que l'on va renvoyer
        reponse["moments"] = []
        for moment in reversed(moments_of_user_past):
            # Si prive il faut que le user qui demande y participe
            if moment.privacy != constants.PRIVATE:
                reponse["moments"].append(moment.moment_to_send(current_user.id))
            elif moment.is_in_guests(current_user.id):
                reponse["moments"].append(moment.moment_to_send(current_user.id))


        for moment in moments_of_user_futur:
            # Pour chacun des Moments on injecte que les données que l'on renvoit, et sous la bonne forme
            if moment.privacy != constants.PRIVATE:
                reponse["moments"].append(moment.moment_to_send(current_user.id))
            elif moment.is_in_guests(current_user.id):
                reponse["moments"].append(moment.moment_to_send(current_user.id))

        reponse["success"] = "OK"

        return jsonify(reponse), 200

    else:
        reponse["error"] = "This user does not exist"
        return jsonify(reponse), 405



##################################################################################
########  Requete pour récupérer les moments sup ou inf à une date ###############
##################################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
# - Date : YYYY-MM-DD
#	

@app.route('/momentsafter/<date>/<int:when>/<int:user_id>', methods=["GET"])
@app.route('/momentsafter/<date>/<int:when>', methods=["GET"])
@app.route('/momentsafter/<date>', methods=["GET"])
@login_required
def moments_after_date(date, when = 1, user_id = 0):
	#On créé la réponse qui sera envoyé
    reponse = {}

    dateRef = fonctions.cast_date(date)

    #Si pas de user fournit alors c'est le current user
    if user_id == 0:
        user = User.query.get(current_user.id)

    #Sinon on cherche les moments d'un autre user
    else:
        user = User.query.get(user_id)
        #Si le user est ferme on peut pas y acceder
        if user.privacy == userConstants.CLOSED:
            reponse["error"] = "This user has a closed profile"
            return jsonify(reponse), 405
        #Si le user est prive, le user logge doit le suivre pour voir ses moments
        elif user.privacy == userConstants.PRIVATE:
            if not current_user.is_following(user):
                reponse["error"] = "This user has a private profile, you must follow him in order to see his moments"
                return jsonify(reponse), 405


    moments = []
    moments_to_send = []

    if dateRef is not None:

        # Si on demande des moments future
        if when == 1:
            #Compteur de moment
            count = 0

            #On recupere les moments sup à cette date
            moments = user.get_moments_sup_date(constants.MAX_MOMENTS, dateRef, False)

            for moment in moments:
                #On verifie que si le moment est privé, alors le current user soit y etre invite
                if moment.privacy == constants.PRIVATE:
                    if moment.is_in_guests(current_user.id):
                        moments_to_send.append(moment.moment_to_send(current_user.id))
                        count += 1

                else:
                    moments_to_send.append(moment.moment_to_send(current_user.id))
                    count += 1



            reponse["success"] = "These are the %s moments after the %s" % (len(moments_to_send), date)


        else:
			#Compteur de moment
            count = 0

            moments = user.get_moments_inf_date(constants.MAX_MOMENTS, dateRef, False)
			
            for moment in moments:
                #On verifie que si le moment est privé, alors le current user soit y etre invite
                if moment.privacy == constants.PRIVATE:
                    if moment.is_in_guests(current_user.id):
                        moments_to_send.append(moment.moment_to_send(current_user.id))
                        count += 1

                else:
                    moments_to_send.append(moment.moment_to_send(current_user.id))
                    count += 1


            reponse["success"] = "These are the %s moments before the %s" % (len(moments_to_send), date)



        reponse["moments"] = moments_to_send


        return jsonify(reponse), 200

    else:

        reponse["error"] = "The date is in the wrong format"
        return jsonify(reponse), 405


#####################################################################
########  Requetes pour récupérer ou modifier un moment ###############
######################################################################
# Methode acceptées : GET, POST
# Paramètres obligatoires :
# 	- Aucune 
#	

@app.route('/moment/<int:id>', methods=["GET", "POST"])
@login_required
def moment(id):
    #On créé la réponse qui sera envoyé
    reponse = {}

    # Si c est une requete POST on modofie le moment
    if request.method == "POST":
        # On recupere le moment
        moment = Moment.query.get(id)

        #Si un moment avec cet id existe
        if moment is not None:

            # Si le user peut modifier le moment
            if moment.can_be_modified_by(current_user.id):
                #On voit quelles valeurs sont présentes et on modifie le moment en fonction
                if "name" in request.form:
                    moment.name = request.form["name"]
                    reponse["name"] = moment.name
                if "description" in request.form:
                    moment.description = request.form["description"]
                    reponse["name"] = moment.name
                if "address" in request.form:
                    moment.address = request.form["address"]
                    reponse["address"] = moment.address
                if "placeInformations" in request.form:
                    moment.placeInformations = request.form["placeInformations"]
                    reponse["placeInformations"] = moment.placeInformations
                if "startDate" in request.form:
                    moment.startDate = fonctions.cast_date(request.form["startDate"])
                    reponse["startDate"] = fonctions.date_to_string(moment.startDate)
                if "endDate" in request.form:
                    moment.endDate = fonctions.cast_date(request.form["endDate"])
                    reponse["endDate"] = fonctions.date_to_string(moment.endDate)
                if "startTime" in request.form:
                    moment.startTime = fonctions.cast_time(request.form["startTime"])
                    reponse["startTime"] = fonctions.time_to_string(moment.startTime)
                if "endTime" in request.form:
                    moment.endTime = fonctions.cast_time(request.form["endTime"])
                    reponse["endTime"] = fonctions.time_to_string(moment.endTime)

                if "photo" in request.files:
                    f = request.files["photo"]
                    image = Image.open(f)
                    #On enregistre la photo et son chemin en base
                    name_picture = "cover"
                    moment.modify_cover_photo(image)
                    reponse["photo"] = moment.cover_picture_url

                if "privacy" in request.form:
                    if int(request.form["privacy"]) == constants.PRIVATE:
                        moment.privacy = constants.PRIVATE
                        reponse["privacy"] = "The moment is now private"
                    elif int(request.form["privacy"]) == constants.OPEN:
                        moment.privacy = constants.OPEN

                        #On rajoute à l'actualité du User qu'il a créé un Moment
                        current_user.add_actu_new_moment(moment)

                        reponse["privacy"] = "The moment is now open"
                    elif int(request.form["privacy"]) == constants.PUBLIC:
                        moment.privacy = constants.PUBLIC

                        #On rajoute à l'actualité du User qu'il a créé un Moment
                        current_user.add_actu_new_moment(moment)

                        reponse["privacy"] = "The moment is now public"

                if "isOpenInvit" in request.form:
                    if request.form["isOpenInvit"] == "0":
                        moment.isOpenInvit = False
                        reponse["isOpenInvit"] = "Guests can't invite other people"
                    elif request.form["isOpenInvit"] == "1":
                        moment.isOpenInvit = True
                        reponse["isOpenInvit"] = "Guests can invite other people"


                #On enregistre
                db.session.commit()

                return jsonify(reponse), 200

            else:
                reponse["error"] = "Not Authorized"
                return jsonify(reponse), 401

        else:
            reponse["error"] = "Moment doesn't exist"
            return jsonify(reponse), 400


    # Sinon on recupere le moment
    elif request.method == "GET":
        moment = Moment.query.get(id)

        #Si le moment existe
        if moment is not None:
            #Si le user fait partie des invité (sinon pas accès à ce moment)
            if moment.is_in_guests(current_user.id):
                reponse = moment.moment_to_send(current_user.id)
            elif moment.privacy == constants.PUBLIC or moment.privacy == constants.OPEN:
                reponse = moment.moment_to_send(current_user.id)
            else:
                reponse["error"] = "Not Authorized"
                return jsonify(reponse), 401


    return jsonify(reponse), 200




#####################################################################
####################  Suppr un moment ###############
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires :
# 	- Aucune 
#	

@app.route('/delmoment/<int:id_moment>', methods=["GET"])
@login_required
def del_moment(id_moment):
	reponse = {}

	#On recupere le moment
	moment = Moment.query.get(id_moment)

	#On verifie que le moment existe
	if moment is not None:
		#On verifie que le user est bien le owner
		if moment.is_owner(current_user):
			#On efface toutes les invitation :
			invitations = Invitation.query.filter(Invitation.moment_id == moment.id).all()

			for invitation in invitations:
				db.session.delete(invitation)

				'''
			#On efface tous les chats
			chats = Chat.query.filter(Chat.moment_id == moment.id).all()

			for chat in chats:
				db.session.delete(chat)
				'''

			#On efface toutes les photos
			photos = Photo.query.filter(Photo.moment_id == moment.id).all()

			for photo in photos:
				photo.delete_photos()
				db.session.delete(photo)

			'''
			#On efface les notifs
			notifications = Notification.query.filter(Notification.moment_id == moment.id).all()

			for notification in notifications:
				db.session.delete(notification)
			'''
			#On supprime la cover
			if moment.cover_picture_path is not None:
				moment.delete_cover_file()

			db.session.delete(moment)
			db.session.commit()

			reponse["success"] = "This moment has been deleted"
			return jsonify(reponse), 200

		else:
			reponse["error"] = "The Moment can only be deleted by his owner"
			return jsonify(reponse), 405

	else:
		reponse["error"] = "This moment does not exist"
		return jsonify(reponse), 405



#####################################################################
####################  Suppr une photo #######################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires :
# 	- Aucune 
#	

@app.route('/delphoto/<int:id_photo>', methods=["GET"])
@login_required
def del_photo(id_photo):
	reponse = {}

	photo = Photo.query.get(id_photo)

	if photo is not None:
		momentPhoto = Moment.query.get(photo.moment_id)

		#On verifie que le user est bien le owner de ce moment ou celui qui l'a posté
		if momentPhoto.is_owner(current_user):
			photo.delete_photos()
			db.session.delete(photo)
			db.session.commit()

			reponse["succes"] = "This photo has been deleted"
			return jsonify(reponse), 200

		elif photo.user_id == current_user.id:
			photo.delete_photos()
			db.session.delete(photo)
			db.session.commit()

			reponse["succes"] = "This photo has been deleted"
			return jsonify(reponse), 200

		else:
			reponse["error"] = "This user is not allowed to delete this photo"
			return jsonify(reponse), 405



	else:
		reponse["error"] = "This photo does not exist"
		return jsonify(reponse), 405



#####################################################################
################  Ajouter des invités à un Moment ###################
######################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	- idMoment, array de User 

@app.route('/newguests/<int:idMoment>', methods=["POST"])
@login_required
def new_guests(idMoment):
	#On créé la réponse qui sera envoyé
	reponse = {}

	#Liste des invités inscrient à Moment (pour envoie mail)
	moment_guests = []
	moment_prospects = []

	# Compteur d'invités rajoutés
	count = 0

	if "users" in request.json:
		# On recupere le Moment en question
		moment = Moment.query.get(idMoment)

		if moment is not None:


			if moment.can_add_guest(current_user.id):

				# On recupere les users fournis dans la requete
				users = request.json["users"]

				#On parcourt la liste des users envoyés
				for user in users:
					#On verifie qu'on a des infos sur le user
					if "id" in user or "email" in user or "phone" in user or "facebookId" in user:

						#Si l'id est fourni normalement il existe dans Moment
						# On va donc le chercher et le rajouté en invité
						if "id" in user:
							user_to_add = User.query.get(user["id"])

							#On verfie que le user existe pour le rajouter
							if user_to_add is not None:

								#Si le user invité est le meme que celui qui fait l'invit c'est qu'il rajoute de moment à ses moments
								if user_to_add.id == current_user.id:
									# On le rajoute et si ça s'est bien passé on incrémente le compteur
									
									if moment.add_myself_to_moment(user_to_add):
										count += 1
										print "Add myself"
									

								else:
									# On le rajoute et si ça s'est bien passé on incrémente le compteur
									if moment.add_guest_user(user_to_add, current_user, userConstants.UNKNOWN):
										count += 1

										#On enregistre dans l'actu de ce user qu'il a été invité
										user_to_add.add_actu_invit(moment)

										#On rajoute ce user à la liste des invités
										moment_guests.append(user_to_add)

						#Sinon c'est un prospect
						else:
							#On verifie que le user n'existe pas quand meme
							if not controller.user_exist(user):
								prospect = controller.get_prospect(user)

								#Pas de prospect
								if prospect is None:
									##
									prospect = Prospect()
									prospect.init_from_dict(user)
									moment.prospects.append(prospect)
									count += 1
									moment_prospects.append(prospect)

								#Le prospect existe
								else:
									prospect.update(user)
									if moment.add_prospect(prospect):
										count += 1
										moment_prospects.append(prospect)

							#Si il esicte on le recupere
							else:
								moment_user = controller.user_from_dict(user)
								if moment.add_guest_user(moment_user, current_user, userConstants.UNKNOWN):
									count += 1
									#On enregistre dans l'actu de ce user qu'il a été invité
									moment_user.add_actu_invit(moment)

									#On rajoute ce user à la liste des invités
									moment_guests.append(moment_user)


				#On enregistre en base
				db.session.commit()

				##
				# Mail Notif
				##

				if len(moment_guests) > 0:
					#On envoit le mail à tous les invités inscris à Moment
					moment.mail_moment_guests(moment_guests, current_user)
				
				reponse["nb_user_added"] = count
				
				#On renvoit tous les prospects invité afin de les inviter par FB ou SMS 
				reponse["prospects_invit"] = []

				for prospect in moment_prospects:
					reponse["prospects_invit"].append(prospect.prospect_to_send())



				return jsonify(reponse), 200

			else:
				reponse["error"] = "Not Aothorized"
				return jsonify(reponse), 401


		else:
			reponse["error"] = "This Moment does not exist"
			return jsonify(reponse), 405


	else:
		reponse["error"] = "mandatory value missing"
		return jsonify(reponse), 405




#####################################################################
########  Requete pour récupérer les infos d'un user connecté ###############
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/user', methods=["GET", "POST"])
@login_required
def user():
	#On créé la réponse qui sera envoyé
    reponse = {}

    user = current_user

    if request.method == 'GET':
        reponse = user.user_to_send()
        return jsonify(reponse), 200

    else:
        reponse["modified_elements"] = {}

        ######
        ## On modifie le FB id
        ######

        if "facebookId" in  request.form:
            user.facebookId = request.form["facebookId"]

            #reponse
            reponse["modified_elements"]["facebookId"] = "Modified with %s" % user.facebookId

                #On voit si un prospect avec ce FacebookID existait
            prospect = Prospect.query.filter(Prospect.facebookId == user.facebookId).first()

            #Si un prospect existait on met à jour le profil et on recupere les moments
            if prospect is not None:
                #On recupere les moments
                prospect.match_moments(user)
                #On met à jour le profil avec les données sur prospect
                user.update_from_prospect(prospect)

                #On efface le prospect
                db.session.delete(prospect)
                db.session.commit()

                reponse["modified_elements"]["facebookId"] = "Modified with %s and some moments matched" % user.facebookId

        ####
        ## On modifie le phone
        ####

        if "phone" in request.form:


            if(len(request.form["phone"])==0):
                if user.phone is not None:
                    user.phone = None
                    reponse["modified_elements"]["phone"] = "phone number removed"

            elif fonctions.phone_controll(request.form["phone"]) is None:
                reponse["error"] = "Wrong phone format"
                return jsonify(reponse), 405

            else:
                phone = fonctions.phone_controll(request.form["phone"])
                user.phone = phone["number"]
                user.phoneCountry = phone["country"]

                reponse["modified_elements"]["phone"] = "Modified with %s" % user.phone

                prospect = Prospect.query.filter(Prospect.phone == user.phone).first()

                #Si un prospect existait on met à jour le profil et on recupere les moments
                if prospect is not None:
                    #On recupere les moments
                    prospect.match_moments(user)
                    #On met à jour le profil avec les données sur prospect
                    user.update_from_prospect(prospect)

                    #On efface le prospect
                    db.session.delete(prospect)
                    db.session.commit()

                    reponse["modified_elements"]["phone"] = "Modified with %s and some moments matched" % user.phone


        ####
        ## On modifie le second phone
        ####

        if "secondPhone" in request.form:

            #If remove phone
            if(len(request.form["secondPhone"])==0):
                if user.secondPhone is not None:
                    user.secondPhone = None
                    reponse["modified_elements"]["phone"] = "phone number removed"

            elif fonctions.phone_controll(request.form["secondPhone"]) is None:
                reponse["error"] = "Wrong phone format"
                return jsonify(reponse), 405

            else:

                phone = fonctions.phone_controll(request.form["secondPhone"])
                user.secondPhone = phone["number"]


                reponse["modified_elements"]["secondPhone"] = "Modified with %s" % user.secondPhone

                prospect = Prospect.query.filter(Prospect.secondPhone == user.secondPhone).first()

                #Si un prospect existait on met à jour le profil et on recupere les moments
                if prospect is not None:
                    #On recupere les moments
                    prospect.match_moments(user)
                    #On met à jour le profil avec les données sur prospect
                    user.update_from_prospect(prospect)

                    #On efface le prospect
                    db.session.delete(prospect)
                    db.session.commit()

                    reponse["modified_elements"]["secondPhone"] = "Modified with %s and some moments matched" % user.secondPhone


        ###
        ## On modifie l'email
        ###

        if "secondEmail" in request.form:
            user.secondEmail = request.form["secondEmail"]

            reponse["modified_elements"]["secondEmail"] = "Modified with %s" % user.secondEmail

            prospect = Prospect.query.filter(or_(Prospect.email == user.secondEmail, Prospect.secondEmail == user.secondEmail)).first()

            #Si un prospect existait on met à jour le profil et on recupere les moments
            if prospect is not None:
                #On recupere les moments
                prospect.match_moments(user)
                #On met à jour le profil avec les données sur prospect
                user.update_from_prospect(prospect)

                #On efface le prospect
                db.session.delete(prospect)
                db.session.commit()

                reponse["modified_elements"]["secondEmail"] = "Modified with %s and some moments matched" % user.secondEmail



        ###
        ## On modifie le prénom
        ###

        if "firstname" in request.form:
            user.firstname = request.form["firstname"]

            reponse["modified_elements"]["firstname"] = "Modified with %s" % user.firstname

        ###
        ## On modifie le nom
        ###

        if "lastname" in request.form:
            user.lastname = request.form["lastname"]

            reponse["modified_elements"]["lastname"] = "Modified with %s" % user.lastname



        ###
        ## On modifie la description
        ###

        if "description" in request.form:
            user.description = request.form["description"]

            reponse["modified_elements"]["description"] = "Modified with %s" % user.description


        ###
        ## On modifie le password
        ###

        if "password" in request.form:
            user.modify_pass(request.form["password"], False)

            reponse["modified_elements"]["password"] = "Password modified"


        ###
        ## On modifie la photo
        ###

        if "photo" in request.files:
            name_picture = "%s" % current_user.id
            user.add_profile_picture_aws(request.files["photo"], name_picture)


        ###
        ## On modifie la date de naissance
        ###

        if "birth_date" in request.form:
            user.birth_date = datetime.date.fromtimestamp(int(request.form["birth_date"]))
            reponse["modified_elements"]["birth_date"] = "The user birth date is %s" % (user.birth_date)

        ###
        ## On modifie le sexe
        ###

        if "sex" in request.form:
            if request.form["sex"] == constants.MALE:
                    user.sex = constants.MALE
                    reponse["modified_elements"]["sex"] = "The user is now a male !"
            elif request.form["sex"] == constants.FEMALE:
                user.sex = constants.FEMALE
                reponse["modified_elements"]["sex"] = "The user is now a female !"

        ###
        ## On modifie la privacy du profil
        ###

        if "privacy" in request.form:
            if int(request.form["privacy"]) == userConstants.OPEN:
                user.privacy = int(userConstants.OPEN)
                reponse["modified_elements"]["privacy"] = "The user profile is now open."
            elif int(request.form["privacy"]) == userConstants.PRIVATE:
                user.privacy = int(userConstants.PRIVATE)
                reponse["modified_elements"]["privacy"] = "The user profile is now protected."
            elif int(request.form["privacy"]) == userConstants.CLOSED:
                user.privacy = int(userConstants.CLOSED)
                reponse["modified_elements"]["privacy"] = "The user profile is now closed."



        db.session.commit()
        return jsonify(reponse), 200


#####################################################################
########  Requete pour récupérer les infos d'un user selon son id ###############
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/user/<int:id>', methods=["GET"])
@login_required
def user_id(id):
	#On créé la réponse qui sera envoyé
	reponse = {}

	user = User.query.get(id)

	reponse = user.user_to_send_social(current_user)

	return jsonify(reponse), 200




#######################################################################################
########  Requete pour modifier le state d'un User pour un moment donné ###############
######################################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/state/<int:moment_id>/<int:state>', methods=["GET"])
@login_required
def modifiy_state(moment_id, state):
    #On créé la réponse qui sera envoyé
    reponse = {}

    user = User.query.get(current_user.id)
    moment = Moment.query.get(moment_id)

    if moment is not None:
        #On verifie que le user est bien dans les invités
        if moment.is_in_guests(current_user.id):
            # On ne modifie que si il n'est pas ADMIN ou OWNER
            if moment.get_user_state(current_user.id) != userConstants.ADMIN and moment.get_user_state(current_user.id) != userConstants.OWNER:
                #On essaye de modifier son état
                if state == userConstants.COMING or state == userConstants.NOT_COMING or state == userConstants.MAYBE:
                    moment.modify_user_state(user, state)
                    if state == userConstants.COMING:
                        user.add_actu_going(moment)
                    #we check that we don't has a going actu, if yes we remove it
                    else:
                        user.remove_going_actu(moment)
                    reponse["new_state"] = state

                else:
                    reponse["error"] = "This state is not valid. State possibles : 2 = Coming, 3 = Not coming, 5 = Maybe"
                    return jsonify(reponse), 405
            else:
                reponse["error"] = "Not Authorized : you can't modify the Admin or Owner state thanks to this request"
                return jsonify(reponse), 401

        else:
            reponse["error"] = "Not Authorized : the user is not a guest of this moment"
            return jsonify(reponse), 401


    else:
        reponse["error"] = "This moment does not exist"
        return jsonify(reponse), 405

    return jsonify(reponse), 200





##########################################################
###############  Ajouter un user en Admin ###############
########################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/admin/<int:moment_id>/<int:user_id>', methods=["GET"])
@login_required
def add_admin(moment_id, user_id):
	#On créé la réponse qui sera envoyé
	reponse = {}

	user = User.query.get(user_id)
	moment = Moment.query.get(moment_id)

	if moment is not None:
		#On verifie que le user qui fait cette requete est soit ADMIN soit OWNER
		if moment.get_user_state(current_user.id) == userConstants.ADMIN or moment.get_user_state(current_user.id) == userConstants.OWNER:
			#On verifie que le user existe bien
			if user is not None:
				#On vérifie que le user est déjà parmis les invités
				if moment.is_in_guests(user_id):
					#On verifie que le user n'est pas déjà owner
					if user != moment.get_owner():
						#Si le user est déjà ADMIN on le passe à COMING
						if moment.is_admin(user):
							moment.modify_user_state(user, userConstants.COMING)
							reponse["success"] = "The user %s %s is no more ADMIN, he is now COMING" % (user.firstname, user.lastname)
						else:
							#Le user devient ADMIN
							moment.modify_user_state(user, userConstants.ADMIN)
							reponse["success"] = "The user %s %s is now the admin of this moment" % (user.firstname, user.lastname)
					else:
						reponse["error"] = "This user is already the owner of this moment"
						return jsonify(reponse), 405
				else:
					reponse["error"] = "Not Authorized : the user is not a guest of this moment"
					return jsonify(reponse), 401

			else:
				reponse["error"] = "The user does not exist"
				return jsonify(reponse), 405
	
		else:
			reponse["error"] = "Not Authorized : only owner or admins of the moment can add an Admin to it"
			return jsonify(reponse), 401

	else:
		reponse["error"] = "This moment does not exist"
		return jsonify(reponse), 405

	return jsonify(reponse), 200






#####################################################################
############ Recupérer les user présents dans Moment ###################
######################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	- array de User avec soit un email, soit un facebookId, soit un phone et aussi soit un secondEmail

@app.route('/usersmoment', methods=["POST"])
@login_required
def users_in_moment():
	#On créé la réponse qui sera envoyé
	reponse = {}
	reponse["moment_users"] = []

	#On liste les User déjà récupéré pour pas en mettre plusieurs fois
	idFound = []

	if "users" in request.json:
		users = request.json["users"]

		#On parcours la liste
		for user in users:
			moment_user = None

			#Si l'email est fourni
			if "email" in user:
				moment_user = User.query.filter_by(email = user["email"]).first()

			#Si on a le facebook Id
			if "facebookId" in user and moment_user is None:
				moment_user = User.query.filter_by(facebookId = user["facebookId"]).first()

			#Si on a le numero de tel
			if "phone" in user and moment_user is None:
				moment_user = User.query.filter_by(phone = user["phone"]).first()

			#Si on a toujours pas de user et qu'on a le secondEmail
			if "secondEmail" in user and moment_user is None:
				moment_user = User.query.filter_by(secondEmail = user["secondEmail"]).first()

			if moment_user is not None:
				reponse["moment_users"].append(moment_user.user_to_send())

		return jsonify(reponse), 200


	else:
		reponse["error"] = "mandatory value missing"
		return jsonify(reponse), 405




######################################################################################
########  Requete pour récupérer les user favoris d'un user authentifié ###############
#####################################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/favoris', methods=["GET"])
@login_required
def favoris():
	#On créé la réponse qui sera envoyé
	reponse = {}
	reponse["favoris"] = []

	#On parcourt les favoris du user
	for fav in current_user.favoris:
		#Si le favoris a le score suffisant
		if fav.score > 5:
			reponse["favoris"].append(fav.the_favoris.user_to_send())

	return jsonify(reponse), 200




######################################################################################
########  Requete pour récupérer les invités à un moment (classé par state) ###############
#####################################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/guests/<int:id_moment>', methods=["GET"])
@login_required
def guests_moment(id_moment):
	#On créé la réponse qui sera envoyé
	reponse = {}
	reponse["owner"] = []
	reponse["admin"] = []
	reponse["coming"] = []
	reponse["not_coming"] = []
	reponse["maybe"] = []
	reponse["unknown"] = []

	moment = Moment.query.get(id_moment)

	if moment is not None:
		#On parcourt tous les invités
		for guest in moment.guests:
			if guest.state == userConstants.OWNER:
				reponse["owner"].append(guest.user.user_to_send())
			elif guest.state == userConstants.ADMIN:
				reponse["admin"].append(guest.user.user_to_send())
			elif guest.state == userConstants.COMING:
				reponse["coming"].append(guest.user.user_to_send())
			elif guest.state == userConstants.NOT_COMING:
				reponse["not_coming"].append(guest.user.user_to_send())
			elif guest.state == userConstants.MAYBE:
				reponse["maybe"].append(guest.user.user_to_send())
			elif guest.state == userConstants.UNKNOWN:
				reponse["unknown"].append(guest.user.user_to_send())

		for prospect in moment.prospects:
			reponse["unknown"].append(prospect.prospect_to_send())

		return jsonify(reponse), 200

	#Ce moment n'existe pas
	else:
		reponse = {}
		reponse["error"] = "This Moment does not exist"
		return jsonify(reponse), 405




#####################################################################
############ Poster une nouvelle photo sur un Moment ###################
######################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	- Une photo

@app.route('/addphoto/<int:moment_id>', methods=["POST"])
@login_required
def new_photos(moment_id):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	#On recupere le moment en question
	moment = Moment.query.get(moment_id)


	if "photo" in request.files:
		image = Image.open(request.files["photo"])


		photo = Photo()

		#On enregistre en base l'objet photo
		db.session.add(photo)
		db.session.commit()

		#Puis on enregistre en disque la photo
		photo.save_photo(image, moment, current_user)

		reponse["success"] = photo.photo_to_send()

		return jsonify(reponse), 200

	else:
		reponse["error"] = "no photo received"
		return jsonify(reponse), 405


#####################################################################
############ Retourne la liste des photos prises pour un moment ###################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/photosmoment/<int:moment_id>', methods=["GET"])
@login_required
def photos_moment(moment_id):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	#On recupere le moment en question
	moment = Moment.query.get(moment_id)

	if moment is not None:
		
		#Si le moment est privé
		if moment.privacy == constants.PRIVATE:
			#On verifie que le user est bien parmis les invites pour acceder aux photos
			if moment.is_in_guests(current_user.id):
				photos = Photo.query.filter(Photo.moment_id == moment_id).order_by(asc(Photo.creation_datetime)).all()
				#filter_by(moment_id=moment_id).order_by(desc(Chat.time)).order_by(asc(Chat.id)).paginate(nb_page, constants.CHATS_PAGINATION, False)
				reponse["photos"] = []
				for photo in photos:
					reponse["photos"].append(photo.photo_to_send())

				return jsonify(reponse), 200


			else:
				reponse["error"] = "This user does not have access to this Moment"
				return jsonify(reponse), 401

		#Si le moment est public (ou ouvert pour le moment) on a aps besoin de savoir si le user est invité
		elif moment.privacy == constants.PUBLIC or moment.privacy == constants.OPEN:
			photos = Photo.query.filter(Photo.moment_id == moment_id).order_by(asc(Photo.creation_datetime)).all()
			#filter_by(moment_id=moment_id).order_by(desc(Chat.time)).order_by(asc(Chat.id)).paginate(nb_page, constants.CHATS_PAGINATION, False)
			reponse["photos"] = []
			for photo in photos:
				reponse["photos"].append(photo.photo_to_send())

			return jsonify(reponse), 200


	else:
		reponse["error"] = "This moment does not exist"
		return jsonify(reponse), 405




#####################################################################
############ Retourne la liste des photos prises par le user ############
############ dans des evenements publics ou ouverts ###################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/photosuser/<int:user_id>', methods=["GET"])
@login_required
def photos_user(user_id):
	#On créé la réponse qui sera envoyé
	reponse = {}
	reponse["photos"] = []
	
	#On recupere le moment en question
	user = User.query.get(user_id)

	if user is not None:

		for photo in user.photos:
			if photo.moment.privacy==constants.PUBLIC:
				reponse["photos"].append(photo.photo_to_send())

		return jsonify(reponse), 200
		
		

	else:
		reponse["error"] = "This user does not exist"
		return jsonify(reponse), 405



#####################################################################
############ Like une photo ou dislike si déjà liké ######
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/like/<int:photo_id>', methods=["GET"])
@login_required
def like_photo(photo_id):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	photo = Photo.query.get(photo_id)

	if photo is not None:
		#On verifie que le user fait partie des invités
		if photo.moment.is_in_guests(current_user.id):
			photo.like(current_user)
			reponse["success"] = "Photo liked"
			reponse["nb_likes"] = len(photo.likes)
			return jsonify(reponse), 200

		elif photo.moment.privacy == constants.PUBLIC or photo.moment.privacy == constants.OPEN:
			photo.like(current_user)
			reponse["success"] = "Photo liked"
			reponse["nb_likes"] = len(photo.likes)
			return jsonify(reponse), 200

		else:
			reponse["error"] = "The user is not authorized to like this photo"
			return jsonify(reponse), 401

	else:
		reponse["error"] = "This photo does not exist"
		return jsonify(reponse), 405



#####################################################################
############ Post un chat du user loggé ############################
######################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
# - Dans l'url : id_moment
#  - Dans le corp : message
#	

@app.route('/newchat/<int:moment_id>', methods=["POST"])
@login_required
def new_chat(moment_id):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	moment = Moment.query.get(moment_id)

	#Si le moment existe
	if moment is not None:
		#On verifie que le user fait partie des invités
		if moment.is_in_guests(current_user.id):
			#Si un message est envoyé
			if "message" in request.form:
				#On créé un nouveau chat lié au user en question et au Moment
				chat = Chat(request.form["message"], current_user, moment)
				

				reponse["success"] = "message added to the chat"
				reponse["chat"] = chat.chat_to_send()
				return jsonify(reponse), 200

			else:
				reponse["error"] = "Mandatory value missing"
				return jsonify(reponse), 405

		#Si le user fait pas partie des invités, on voit si le moment est public (ou open pour le moment)
		elif moment.privacy == constants.PUBLIC or moment.privacy == constants.OPEN:
			#Si un message est envoyé
			if "message" in request.form:
				#On créé un nouveau chat lié au user en question et au Moment
				chat = Chat(request.form["message"], current_user, moment)
				

				reponse["success"] = "message added to the chat"
				reponse["chat"] = chat.chat_to_send()
				return jsonify(reponse), 200

			else:
				reponse["error"] = "Mandatory value missing"
				return jsonify(reponse), 405


		else:
			reponse["error"] = "The user is not a guest of this moment"
			return jsonify(reponse), 401

		

	else:
		reponse["error"] = "This moment does not exist"
		return jsonify(reponse), 405


#####################################################################
############ Recuperer les x dernier chat ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/lastchats/<int:moment_id>', methods=["GET"])
@app.route('/lastchats/<int:moment_id>/<int:nb_page>', methods=["GET"])
@login_required
def last_chats(moment_id, nb_page = 1):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	moment = Moment.query.get(moment_id)

	if moment is not None:
		#On verifie que le user fait partie des invités
		if moment.is_in_guests(current_user.id):
			#On recupere les chats de ce Moment, au format pagination
			chatsPagination = Chat.query.filter_by(moment_id=moment_id).order_by(desc(Chat.time)).order_by(asc(Chat.id)).paginate(nb_page, constants.CHATS_PAGINATION, False)

			#Si il y a des pages suivantes
			if chatsPagination.has_next:
				reponse["next_page"] = chatsPagination.next_num
			#Si il y a une page precedente
			if chatsPagination.has_prev:
				reponse["prev_page"] = chatsPagination.prev_num

			#On construit le tableau des messages
			reponse["chats"] = []
			for chat in chatsPagination.items:
				reponse["chats"].append(chat.chat_to_send())

			reponse["chats"].reverse()
			return jsonify(reponse), 200

		#Si le user fait pas partie des invités, on voit si le moment est public (ou open pour le moment)
		elif moment.privacy == constants.PUBLIC or moment.privacy == constants.OPEN:
			#On recupere les chats de ce Moment, au format pagination
			chatsPagination = Chat.query.filter_by(moment_id=moment_id).order_by(desc(Chat.time)).order_by(asc(Chat.id)).paginate(nb_page, constants.CHATS_PAGINATION, False)

			#Si il y a des pages suivantes
			if chatsPagination.has_next:
				reponse["next_page"] = chatsPagination.next_num
			#Si il y a une page precedente
			if chatsPagination.has_prev:
				reponse["prev_page"] = chatsPagination.prev_num

			#On construit le tableau des messages
			reponse["chats"] = []
			for chat in chatsPagination.items:
				reponse["chats"].append(chat.chat_to_send())

			reponse["chats"].reverse()
			return jsonify(reponse), 200
		else:
			reponse["error"] = "The user is not a guest of this moment"
			return jsonify(reponse), 401

	else:
		reponse["error"] = "This moment does not exist"
		return jsonify(reponse), 405



#####################################################################
############ Recuperer un chat ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/chat/<int:chat_id>', methods=["GET"])
@login_required
def chat(chat_id):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	

	chat = Chat.query.filter(Chat.id==chat_id).first()

	if chat is None:
		reponse["error"] = "This chat does not exist"
		return jsonify(reponse), 405

	else:
		moment = Moment.query.get(chat.moment_id)

		#Le user doit être invité à ce moment
		if moment.is_in_guests(current_user.id):
			#On construit le tableau des messages
			reponse["chat"] = chat.chat_to_send()

			return jsonify(reponse), 200
		else:
			reponse["error"] = "The user is not a guest of this moment"
			return jsonify(reponse), 401




#####################################################################
############ Recuperer les notifications d'un user #################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/notifications', methods=["GET"])
@app.route('/notifications/<int:nb_page>', methods=["GET"])
@login_required
def notifications(nb_page = 1):
	#On créé la réponse qui sera envoyé
	reponse = {}
	reponse["invitations"] = []
	reponse["new_photos"] = []
	reponse["new_chats"] = []
	reponse["modif_moment"] = []
	reponse["notifications"] = []
	reponse["invitations"] = []

	#Le nombre total de notifs (notifs + invitations)
	reponse["total_notifs"] = current_user.nb_notif_unread()

	#On recupere le nb de nouvelles notifs et en même temps on les archive
	reponse["nb_new_notifs"] = current_user.archive_notifs()



	notificationPagination = Notification.query.filter(and_(Notification.user_id == current_user.id, Notification.type_notif != userConstants.INVITATION)).order_by(desc(Notification.time)).paginate(nb_page, constants.NOTIFS_PAGINATION, False)


	if notificationPagination.has_next:
		reponse["next_page"] = notificationPagination.next_num

	if notificationPagination.has_prev:
		reponse["prev_page"] = notificationPagination.prev_num
	
	for notification in notificationPagination.items:

		reponse["notifications"].append(notification.notif_to_send())


	return jsonify(reponse), 200





#####################################################################
############ Recuperer les invitations d'un user #################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/invitations', methods=["GET"])
@app.route('/invitations/<int:nb_page>', methods=["GET"])
@login_required
def invitations(nb_page = 1):
	#On créé la réponse qui sera envoyé
	reponse = {}
	reponse["invitations"] = []

	#Le nombre total de notifs (notifs + invitations)
	reponse["total_notifs"] = current_user.nb_notif_unread()

	#On recupere le nb de nouvelles notifs et en même temps on les archive
	reponse["nb_new_invits"] = current_user.archive_invitations()


	invitationPagination = Notification.query.filter(and_(Notification.user_id == current_user.id, Notification.type_notif == userConstants.INVITATION)).order_by(desc(Notification.time)).paginate(nb_page, constants.NOTIFS_PAGINATION, False)


	if invitationPagination.has_next:
		reponse["next_page"] = invitationPagination.next_num

	if invitationPagination.has_prev:
		reponse["prev_page"] = invitationPagination.prev_num
	
	for invitation in invitationPagination.items:

		reponse["invitations"].append(invitation.notif_to_send())


	return jsonify(reponse), 200


#####################################################################
############ REset Notifications une fois luz #################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/resetnotifications', methods=["GET"])
@login_required
def reset_notifications():
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	'''
	for notification in current_user.notifications:
		db.session.delete(notification)

	db.session.commit()
	'''
	reponse["success"] = "Notifications emptied"

	return jsonify(reponse), 200



#####################################################################
############ Matcher les moments avec un code #######################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/matchcode/<code>', methods=["GET"])
@login_required
def match_code(code):
	#On créé la réponse qui sera envoyé
	reponse = {}
	
	prospect = Prospect.query.filter(Prospect.unique_code == code).first()

	if prospect is None:
		reponse["error"] = "This code does not exist"
		return jsonify(reponse), 405

	else:
		#On recupere les moments
		prospect.match_moments(current_user)
		#On met à jour le profil avec les données sur prospect
		current_user.update_from_prospect(prospect)

		#On efface le prospect
		db.session.delete(prospect)
		db.session.commit()

		reponse["success"] = "The Moments have been matched"
		return jsonify(reponse), 200




#####################################################################
############ Tris les evenements Facebook entre ceux déjà existans   ###################
############ ceux existant et où le user est invité, ceux non existants #######################
######################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
#	

@app.route('/facebookevents', methods=["POST"])
@login_required
def facebookevents():

	reponse = {}
	reponse["exist_and_invited"] = []
	reponse["exist"] = []
	reponse["not_exist"] = []

	#On recupere tous les facebookId
	if "events" in request.json:
		events = request.json["events"]

		#Pour chaque facebookId
		for event in events:
			fbEvent = Moment.query.filter(Moment.facebookId == event).first()

			#Si un moment avec ce facebookID existe
			if fbEvent is not None:

				#Si le user fait parti des invité
				if fbEvent.is_in_guests(current_user.id):
					reponse["exist_and_invited"].append(fbEvent.facebookId)
				else:
					reponse["exist"].append(fbEvent.facebookId)

			else:
				reponse["not_exist"].append(event)

		return jsonify(reponse), 200

	else:
		reponse = {}
		reponse["error"] = "no events provided"
		return jsonufy(reponse), 405


#####################################################################
############ Modifier la privacy du Moment #######################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/openmoment/<int:id_moment>', methods=["GET"])
@login_required
def privacy_moment(id_moment):

	reponse = {}

	moment = Moment.query.get(id_moment)

	if moment is not None:
		if moment.isOpenInvit:
			moment.isOpenInvit = False
			reponse["success"] = "Moment is now closed"
		else:
			moment.isOpenInvit = True
			reponse["success"] = "Moment is now open"

		db.session.commit()
		return jsonify(reponse), 200

	else:
		moment["error"] = "This moment does not exist"
		return jsonify(reponse), 405



#####################################################################
############ Recherche de user ou moment ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/search/<search>', methods=["GET"])
@login_required
def search(search):
	reponse = {}


	########
	## Recherche des Users
	########

	#On recherche des user dont le prénom ou le nom corresponde
	#Pour les noms on decompose car la premiere partie correspondra à nom ou prénom et l'autre à nom ou prenom

	decSearch = search.split(" ", 2)


	#Si le texte est composé d'un seul mot
	if len(decSearch)==1:

		#on recupere d'abord les users qu'il follow
		usersPerso = []

		for user in current_user.follows:
			if user.firstname.lower().startswith(decSearch[0].lower()):
				usersPerso.append(user)
			elif user.lastname.lower().startswith(decSearch[0].lower()):
				usersPerso.append(user)

		#Puis les users autres classé par gd nb de followers et limité à 20
		users = User.query.filter(and_(or_(User.firstname.ilike(decSearch[0]+"%"), User.lastname.ilike(decSearch[0]+"%")), User.privacy != userConstants.CLOSED)).limit(20).all()
		print len(users)


	#Sinon on peut avoir nom et prenom
	else:
		#on recupere d'abord les users qu'il follow
		usersPerso = []

		for user in current_user.follows:
			if user.firstname.lower().startswith(decSearch[0].lower()) and user.lastname.lower().startswith(decSearch[1].lower()):
				usersPerso.append(user)
			elif user.lastname.lower().startswith(decSearch[0].lower()) and user.firstname.lower().startswith(decSearch[1].lower()):
				usersPerso.append(user)


		users = User.query.filter(and_(or_(and_(User.firstname.ilike(decSearch[0]+"%"), User.lastname.ilike(decSearch[1]+"%")), and_(User.lastname.ilike(decSearch[0]+"%"), User.firstname.ilike(decSearch[1]+"%"))), User.privacy != userConstants.CLOSED)).limit(20).all()


	#On envoie tous les users trouvés
	reponse["users"] = []

	#On met d'abord les user qui sont suivis
	for user in usersPerso:
		reponse["users"].append(user.user_to_send_social(current_user))


	#Puis les autres
	for user in users:
		if not current_user.is_following(user):
			reponse["users"].append(user.user_to_send_social(current_user))


	#######
	## REcherche des moments persos
	######

	reponse["user_moments"] = []
	momentsPerso = Moment.query.join(Moment.guests).join(Invitation.user).filter(User.id== current_user.id).filter(Moment.name.ilike("%"+search+"%")).order_by(Moment.startDate.asc()).all()

	for moment in momentsPerso:
		reponse["user_moments"].append(moment.moment_to_send(current_user.id))


	#######
	## Recherche des moments publics
	######

	reponse["public_moments"] = []
	momentsPublic = Moment.query.filter(and_(Moment.name.ilike("%"+search+"%"), Moment.privacy == constants.PUBLIC)).all()

	for moment in momentsPublic:
		if not moment.is_in_guests(current_user.id):
			reponse["public_moments"].append(moment.moment_to_send(current_user.id))





	return jsonify(reponse), 200



#####################################################################
############ Changer MDP (STTTTTTOOOOPPP CEETTEE REQUETE) ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	

@app.route('/changepassword/<passw>/<oldpass>', methods=["GET"])
@login_required
def password(passw, oldpass):

    reponse = {}

    user = current_user

    if oldpass is not None:
        if hashpw(oldpass, user.pwd) == user.pwd:
            user.pwd = hashpw(passw, gensalt())
            db.session.commit()
            reponse["success"] = "Don't loose your password again (old one given) ! This is the new one : %s" % passw
            return jsonify(reponse), 200
        else:
            reponse["error"] = "Wrong old password"
            return jsonify(reponse), 400

    if user is not None:
        user.pwd = hashpw(passw, gensalt())
        db.session.commit()

        reponse["success"] = "Don't loose your password again ! This is the new one : %s" % passw
        return jsonify(reponse), 200

    else:
        reponse["error"] = "This user does not exist"
        return jsonify(reponse), 405




#####################################################################
############ S   O   C    I   A   L #################################
############ S   O   C    I   A   L #################################
############ S   O   C    I   A   L #################################
############ S   O   C    I   A   L #################################
######################################################################


#####################################################################
############ Suivre quelqu'un ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/addfollow/<int:user_id>', methods=["GET"])
@login_required
def add_follow(user_id):
    reponse = {}

    userToFollow = User.query.get(user_id)



    #Si le user existe
    #### Ici VOIR EN FONCTION DE LA PRIVACY DE CHAQUE USER  (PUBLIC , SEMI OUVERT, FERME)
    if userToFollow is not None:

        #On verifie que le user n'est pas fermé
        if userToFollow.privacy == userConstants.CLOSED:
            reponse["error"] = "This user is private thus it can't be followed"
            return jsonify(reponse), 405

        #Si le user est protégé
        elif userToFollow.privacy == userConstants.PRIVATE:
            #If the user is not requested
            if not current_user.is_requesting(userToFollow):
                #If the user is not followed
                if not current_user.is_following(userToFollow):
                    current_user.request_follow(userToFollow)
                    reponse["success"] = "Request sent to the user"
                    reponse["code_follow"] = 1
                    return jsonify(reponse), 200
                else:
                    current_user.remove_follow(userToFollow)
                    reponse["success"] = "This user is no more followed"
                    return jsonify(reponse), 200

            else:
                reponse["error"] = "The request is already made"
                return jsonify(reponse), 405


        #User OPEN
        else:
            if not current_user.is_following(userToFollow):
                if current_user.add_follow(userToFollow):
                    reponse["success"] = "User added to the people followed"
                    reponse["code_follow"] = 0
                    return jsonify(reponse), 200

                #Sinon (probablement dejà suivi)
                else:
                    reponse["error"] = "User not followed (probably already followed)"
                    return jsonify(reponse), 405

            #Sinon on le retire de ceux suivis
            else:
                current_user.remove_follow(userToFollow)
                reponse["success"] = "This user is no more followed"
                return jsonify(reponse), 200


    else:
        reponse["error"] = "This user does not exist"
        return jsonify(reponse), 405



#####################################################################
############ Accepter requete de follow ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/acceptfollow/<int:user_id>', methods=["GET"])
@login_required
def accept_follow(user_id):
	reponse = {}

	user = User.query.get(user_id)

	if user is not None:
		
		
		if user.validate_request(current_user):
			reponse["success"] = "The user is now followed"
			return jsonify(reponse), 200

		else:
			reponse["error"] = "An error occured. Maybe the user was already followed, or there was no follow request on this user"
			return jsonify(reponse), 405


	else:
		reponse["error"] = "This user does not exist"
		return jsonify(reponse), 405


#####################################################################
############ Refuser requete de follow ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires :
#


@app.route('/refusefollow/<int:user_id>', methods=["GET"])
@login_required
def refuse_follow(user_id):
	reponse = {}

	user = User.query.get(user_id)

	if user is not None:


		if user.refuse_request(current_user):
			reponse["success"] = "The request has been cancelled"
			return jsonify(reponse), 200

		else:
			reponse["error"] = "An error occured. Maybe the user was already followed, or there was no follow request on this user"
			return jsonify(reponse), 405


	else:
		reponse["error"] = "This user does not exist"
		return jsonify(reponse), 405


#####################################################################
############ Recuperer les personnes suivis ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/follows/<int:user_id>', methods=["GET"])
@login_required
def get_follows(user_id):
	reponse = {}

	user = User.query.get(user_id)

	if user is not None:
		reponse["follows"] = []

		if user.follows is not None:	
			for follow in user.follows:
				reponse["follows"].append(follow.user_to_send_social(current_user))

		return jsonify(reponse), 200

	else:
		reponse["error"] = "This user does not exist"
		return jsonify(reponse), 405


#####################################################################
############ Recuperer les personnes qui suivent ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/followers/<int:user_id>', methods=["GET"])
@login_required
def get_followers(user_id):
	reponse = {}

	user = User.query.get(user_id)

	if user is not None:
		reponse["followers"] = []

		if user.followers is not None:
			for follower in user.followers:
				reponse["followers"].append(follower.user_to_send_social(current_user))

		return jsonify(reponse), 200

	else:
		reponse["error"] = "This user does not exist"
		return jsonify(reponse), 405



#####################################################################
############ Recuperer le feed du user ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/feed', methods=["GET"])
@app.route('/feed/<int:nb_page>', methods=["GET"])
@login_required
def feed(nb_page = 1):
	reponse = {}

	#On update son feed
	current_user.update_feed()

	#On recupere ses feed
	feedsPages = Feed.query.filter(Feed.user_id == current_user.id).order_by(desc(Feed.time)).paginate(nb_page, constants.FEED_PAGINATION, False)

	#Si il y a des pages suivantes
	if feedsPages.has_next:
		reponse["next_page"] = feedsPages.next_num
	#Si il y a une page precedente
	if feedsPages.has_prev:
		reponse["prev_page"] = feedsPages.prev_num

	#On construit le tableau des messages
	reponse["feeds"] = []
	for feed in feedsPages.items:
		reponse["feeds"].append(feed.feed_to_send())

	return jsonify(reponse), 200




#####################################################################
############ Recuperer les params de notifs ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/paramsnotifs', methods=["GET"])
@login_required
def params_notifs():
	reponse = {}

	reponse["params_notifs"] = []

	for paramn_notif in current_user.param_notifs:
		reponse["params_notifs"].append(paramn_notif.params_notifs_to_send())


	return jsonify(reponse), 200


#####################################################################
############ Modifier les params de notifs ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/paramsnotifs/<int:mode>/<int:type_notif>', methods=["GET", "POST"])
@login_required
def params_notifs_modif(mode, type_notif):
    reponse = {}

    if request.method == "POST":
        if 'notif_id' in request.form and "device_id" in request.form:
            device = current_user.get_device(request.form["device_id"])

            if device is not None:
                device.notif_id = request.form["notif_id"]
            else:
                reponse["error"] = "This device does not exist"
                return jsonify(reponse), 405


    for paramn_notif in current_user.param_notifs:
        if paramn_notif.type_notif == type_notif:
            #On modifie les mails
            if mode == 0:
                if paramn_notif.mail:
                    paramn_notif.mail = False

                    #On enregistre
                    db.session.commit()

                    reponse["success"] = "Mail desactivated for type_notif = %s" % type_notif
                    return jsonify(reponse), 200
                else:
                    paramn_notif.mail = True

                    #On enregistre
                    db.session.commit()

                    reponse["success"] = "Mail activated for type_notif = %s" % type_notif
                    return jsonify(reponse), 200

            #On modifie le push
            elif mode == 1:
                #On verifie que l'on a un notif_id
                if current_user.has_notif_id():
                    if paramn_notif.push:
                        paramn_notif.push = False

                        #On enregistre
                        db.session.commit()

                        reponse["success"] = "Push desactivated for type_notif = %s" % type_notif
                        return jsonify(reponse), 200
                    else:
                        paramn_notif.push = True

                        #On enregistre
                        db.session.commit()

                        reponse["success"] = "Push activated for type_notif = %s" % type_notif
                        return jsonify(reponse), 200
                else:
                    reponse["error"] = "No notif_id"
                    return jsonify(reponse), 400


            #Sinon mode inconnu
            else:
                reponse["error"] = "This mode is not known"
                return jsonify(reponse), 405

    reponse["error"] = "This type of notif is not known"
    return jsonify(reponse), 405







#####################################################################
############ INSTAGRAM ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
#	


@app.route('/updateinstagram/tag', methods=["GET", "POST"])
def instagram_tag():

	from instagram import client, subscriptions

	

	print "INSTAGRAM ARRIVE" 
	
	if request.method == "GET": 

		mode         = request.values.get('hub.mode')
		challenge    = request.values.get('hub.challenge')
		verify_token = request.values.get('hub.verify_token')
		print verify_token
		return challenge

	else:

		print "INSTAGRAM"

		reactor = subscriptions.SubscriptionsReactor()
    	reactor.register_callback(subscriptions.SubscriptionType.TAG, fonctions.update_moment_tag)

    	x_hub_signature = request.headers.get('X-Hub-Signature')
    	raw_response    = request.data
        
        try:
            reactor.process(constants.INSTAGRAM_CLIENT_SECRET, raw_response, x_hub_signature)
        except subscriptions.SubscriptionVerifyError:
        	print 'Instagram signature mismatch'

    	
    	return 'Parsed instagram'


#####################################################################
############  Password Oublié ############################
######################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 
# - Dans l'url : email
#	

@app.route('/lostpass/<email>', methods=["GET"])
def lost_pass(email):
	reponse = {}

	user = User.query.filter(User.email == email).first()

	new_pass = fonctions.random_pass()
	user.modify_pass(new_pass, True)

	reponse["sucess"] = "New password sent to %s" % (user.email)

	return jsonify(reponse), 200




#####################################################################
############  Logout de l'app  et deconnection du device ############################
######################################################################
# Methode acceptées : GET
# Paramètres obligatoires : 
# 
#	

@app.route('/logout/<device_id>', methods=["GET"])
@login_required
def logout(device_id):
	reponse = {}

	deviceRemoved = False

	for device in current_user.devices:
		if device.device_id == device_id:
			current_user.devices.remove(device)
			db.session.commit()
			deviceRemoved = True



	if deviceRemoved:
		reponse["success"] = "One device removed. See you !"
		return jsonify(reponse), 200
	else:
		reponse["error"] = "No device removed"
		return jsonify(reponse), 405

	




#####################################################################
############ FACEBOOK REAL TIME ############################
######################################################################
'''

@app.route('/realtime/fb', methods=["GET", "POST"])
def fb_real_time():

	if request.method == "GET": 

		mode         = request.values.get('hub.mode')
		challenge    = request.values.get('hub.challenge')
		verify_token = request.values.get('hub.verify_token')


		#On verifie que c'est bien le verify_token de facebook
		if verify_token == constants.FB_EVENT_VERIFY_TOKEN:
			return challenge

		else: 
			print "PAS FACEBOOK"
			return "nop"

	elif request.method == "POST":
		print "FACEBOOK : %s" % request.json

'''



#############################################################
############ REQUETE API PHOTO ############################
#############################################################
		

@app.route('/p/<unique_id>', methods=["GET"])
@fonctions.crossdomain(origin='*')
def photo_unique(unique_id):
    reponse = {}

    photo = Photo.query.filter(Photo.unique_code == unique_id).first()

    if photo is None:
        reponse["error"] = "This photo does not exist"
        return jsonify(reponse), 405
    else:
        reponse["photo"] = photo.photo_to_send_ext()
        return jsonify(reponse), 200



#############################################################
############ REQUETE API MOMENT ############################
#############################################################


@app.route('/mo/<unique_id>', methods=["GET"])
@fonctions.crossdomain(origin='*')
def moment_unique(unique_id):
    reponse = {}

    moment = Moment.query.filter(Moment.unique_code == unique_id).first()

    if moment is None:
        reponse["error"] = "This moment does not exist"
        return jsonify(reponse), 405
    else:
        reponse["moment"] = moment.moment_to_send_ext()
        return jsonify(reponse), 200






		











