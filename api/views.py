# -*- coding: utf-8 -*-

from flask import request, abort, redirect, url_for
from api import app, db, login_manager
import json
from bcrypt import hashpw, gensalt
from flask.ext.login import (LoginManager, current_user, login_required,
                            login_user, logout_user, UserMixin, AnonymousUser,
                            confirm_login, fresh_login_required)
from api.models import User
from itsdangerous import URLSafeSerializer




###################################
###### Flask Login functions ######
####################################

#Login_serializer used to encryt and decrypt the cookie token for the remember
#me option of flask-login
login_serializer = URLSafeSerializer(app.secret_key)

@login_manager.user_loader
def load_user(userid):
    """
    Flask-Login user_loader callback.
    The user_loader function asks this function to get a User Object or return 
    None based on the userid.
    The userid was stored in the session environment by Flask-Login.  
    user_loader stores the returned User object in current_user during every 
    flask request. 
    """
    return User.query.get(userid)


@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback. 
    The token_loader function asks this function to take the token that was 
    stored on the users computer process it to check if its valid and then 
    return a User Object if its valid or None if its not valid.
    """

    #The Token itself was generated by User.get_auth_token.  So it is up to 
    #us to known the format of the token data itself.  

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which 
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre. 
    #max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()

    #Decrypt the Security Token, data = [username, hashpass]
    data = login_serializer.loads(token)

    #Find the User
    user = User.query.filter_by(email = data[0])

    #Check Password and return user or None
    if user and data[1] == user.pwd:
        return user
    return None







    #######################################################
    ################# REQUETES ############################
    #######################################################






@app.route('/')
@login_required
def index():
	user = User.query.filter(User.username == 'adriendulong').first()
	if user is None:
		return current_user.email
	else:
		return user.email



#################################################################
######## Requete pour enregistrer un nouvel utilisateur #########
##################################################################
# Methode acceptées : POST
# Paramètres obligatoires : 

@app.route('/register', methods=["POST"])
def register():
	#On verifie que tous les champs sont renseignes
	if request.method == "POST" and "username" in request.form and "password" in request.form and "email" in request.form and "age" in request.form :

		#On recupere toutes les variable
		username = request.form["username"]
		password = request.form["password"]
		hashpwd = hashpw(password, gensalt())
		email = request.form["email"]

		#On verifie que age soit bien au format int
		try:
			age = int(request.form["age"])
		except ValueError:
			abort(400)

		#On cree l'utilisateur
		user = User(username, email, age, hashpwd)

		#On l ajoute en base
		db.session.add(user)
		db.session.commit()

		reponse = {}
		reponse["username"] = username
		reponse["password"] = password
		reponse["hashpwd"] = hashpwd
		reponse["email"] = email
		reponse["age"] = age

		return json.dumps(reponse)

	else:
		abort(400)





######################################################
########  Requete pour Logger un  user ###############
#######################################################


@app.route('/login', methods=["POST"])
def login():
	#On verifie que tous les champs sont renseignes
	if request.method == "POST" and "email" in request.form and "password" in request.form:
		email = request.form["email"]
		password = request.form["password"]

		#On recupere l utilisateur ayant de username
		user = User.query.filter_by(email = email).first()

		# Si l'utilisateur n'existe pas
		if user is None:
			return "User does not exist"
		else:
			# On verifie que le password hashé correspond bien à celui en base
			if hashpw(password, user.pwd) == user.pwd:
				login_user(user)
				return "Ok"
			else:
				return "wrong password"

	else:
		abort(400)








